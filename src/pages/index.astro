---
import TerminalHero from "../components/TerminalHero.astro";
import Navigation from "../components/Navigation.astro";
import Footer from "../components/Footer.astro";
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>William64.com</title>
    <meta
      name="description"
      content="A minimalist, terminal-inspired personal site of William Sutton, software engineer and retro-tech enthusiast."
    />

    <!-- Strategic Preloading -->
    <link rel="preload" href="/styles.css" as="style" />
    <link rel="preload" href="/main.js" as="script" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="modulepreload" href="/_astro/TerminalHeroClient.L1wAk-Fv.js" />

    <!-- Add Press Start 2P font for the retro banner -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />

    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body class="bg-black text-green-400 font-mono">
    <div class="w-full px-4 md:px-8">
      <!-- Demo Scene Banner - Now at the very top with enhanced visuals -->
      <div class="demo-scene-banner mb-6 h-[32rem] min-h-[400px]">
        <canvas id="bannerCanvas" class="w-full h-auto"></canvas>
        <div class="banner-audio">
          <audio id="chiptune" loop>
            <source src="/assets/chiptune.mp3" type="audio/mp3" />
          </audio>
          <button id="audioToggle">â™«</button>
        </div>
      </div>

      <div class="p-4">
        <div class="navbar">
          <header>
            <!-- Removed the text "William64.com" since it's now in the banner -->
            <Navigation />
            <p class="text-sm text-green-600">
              Minimalist. Professional. Retro Hacker.
            </p>
          </header>

          <main>
            <TerminalHero />

            <section class="mb-12">
              <h2 class="text-2xl border-b border-green-700 pb-2 mb-4">
                Latest Posts
              </h2>
              <ul id="post-list" class="space-y-6">
                <!-- Posts will be injected here by client-side JS -->
              </ul>
            </section>

            <section class="mb-12">
              <h2 class="text-2xl border-b border-green-700 pb-2 mb-4">
                Projects
              </h2>
              <div class="space-y-6">
                <div>
                  <h3 class="text-xl font-bold">tpc-server</h3>
                  <p class="text-green-300">
                    A Python MCP server for managing thoughts, plans, and
                    changelogs with a structured database. Provides tools for
                    recording insights, planning approaches, and tracking
                    changes.
                  </p>
                </div>
              </div>
            </section>

            <section>
              <h2 class="text-2xl border-b border-green-700 pb-2 mb-4">
                About Me
              </h2>
              <p class="mb-4">
                I'm a software engineer with a passion for clean systems, deep
                logic, and building elegant solutions to gnarly problems. This
                is my digital workshopâ€”welcome.
              </p>
            </section>
          </main>
          <Footer />
        </div>
      </div>
    </div>

    <script is:inline src="/main.js"></script>

    <!-- Demo Scene Banner Script with enhanced effects and longer sequences -->
    <script is:inline>
      document.addEventListener("DOMContentLoaded", () => {
        const canvas = document.getElementById("bannerCanvas");
        const ctx = canvas.getContext("2d");
        const audio = document.getElementById("chiptune");
        const audioToggle = document.getElementById("audioToggle");

        // Set canvas dimensions
        // Set canvas to fill container while maintaining aspect ratio
        const targetHeight = Math.min(canvas.offsetHeight, window.innerHeight * 0.6);
        const targetWidth = canvas.offsetWidth;
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        
        // Scale drawing operations to match canvas size
        ctx.scale(targetWidth / 800, targetHeight / 400);  // Base size 800x400

        // Audio toggle
        audioToggle.addEventListener("click", () => {
          if (audio.paused) {
            audio.play();
            audioToggle.textContent = "ðŸ”Š";
          } else {
            audio.pause();
            audioToggle.textContent = "â™«";
          }
        });

        // Scene state
        let state = {
          phase: "loading", // loading, intro, logo, effects, plasma, fire, voxel, paragraph, greetz, outro
          time: 0,
          stars: Array(400)
            .fill()
            .map(() => ({
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              speed: 1 + Math.random() * 6,
              size: Math.random() > 0.8 ? 3 : 1.5,
              color: Math.random() > 0.5 ? "#00ff00" : "#ff00ff",
            })),
          loadingProgress: 0,
          greetsList: [
            "cDc",
            "Phrozen Crew",
            "Razor 1911",
            "Fairlight",
            "Deviance",
            "mobman",
            "3dBuzz",
            "Paul Frazee",
            "Vitalik Buterin",
            "Nikola Tesla",
            "Ada Lovelace",
            "DEFCON",
            "BlackHat",
            "CCC",
            "HOPE",
            "xCopyz",
            "LekTrix",
            "TLB",
            "UNiX",
          ],
          greetzIndex: 0,
          introLines: [],
          sinOffset: 0,
          glitchTime: 0,
          plasma: createPlasmaTexture(),
          fire: createFireTexture(),
          cube: { rotation: 0, vertices: createCube() },
          voxel: { position: { x: 0, y: 0 }, data: createVoxelWorld() },
          paragraphText: [
            "IN A WORLD OF BLOATED",
            "CODE AND CHEAP TRICKS,",
            "WE STAND FOR PURE",
            "ALGORITHMIC BEAUTY.",
            "",
            "EVERY BYTE COUNTS.",
            "EVERY CYCLE MATTERS.",
            "THIS IS THE WAY OF",
            "THE DIGITAL WARRIOR.",
            "",
            "OPTIMIZATION IS NOT",
            "JUST ABOUT SPEED,",
            "IT'S ABOUT ELEGANCE",
            "AND RESPECT FOR THE",
            "MACHINE.",
            "",
            "WE ARE THE KEEPERS",
            "OF THE OLD WAYS,",
            "WHEN CODE WAS ART",
            "AND COMPUTING WAS",
            "FREEDOM.",
            "",
            "EDISON STOLE GLORY.",
            "TESLA GAVE BRILLIANCE.",
            "BE LIKE TESLA.",
            "FUCK THOMAS EDISON.",
          ],
          paragraphIndex: 0,
          paragraphChar: 0,
          paragraphPage: 0,
          lensFlares: createLensFlares(),
        };

        // Generate intro lines effect (matrix-like)
        for (let i = 0; i < 30; i++) {
          state.introLines.push({
            x: Math.random() * canvas.width,
            speed: 1 + Math.random() * 5,
            chars: generateRandomChars(10 + Math.floor(Math.random() * 20)),
          });
        }

        // Animation loop
        function animate() {
          ctx.fillStyle = "black";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Draw starfield in most phases
          if (
            state.phase !== "effects" &&
            state.phase !== "plasma" &&
            state.phase !== "fire" &&
            state.phase !== "voxel"
          ) {
            drawStars();
          }

          // Draw phase-specific content
          switch (state.phase) {
            case "loading":
              drawLoading();
              break;
            case "intro":
              drawIntro();
              break;
            case "logo":
              drawLogo();
              break;
            case "effects":
              drawEffects();
              break;
            case "plasma":
              drawPlasma();
              break;
            case "fire":
              drawFire();
              break;
            case "voxel":
              drawVoxel();
              break;
            case "paragraph":
              drawParagraph();
              break;
            case "greetz":
              drawGreetz();
              break;
            case "outro":
              drawOutro();
              break;
          }

          // Draw lens flares in all phases except loading
          if (state.phase !== "loading") {
            drawLensFlares();
          }

          // Draw scanlines in all phases
          drawScanlines();

          // Occasional glitch effect
          if (Math.random() > 0.99) {
            state.glitchTime = 0.15;
          }

          if (state.glitchTime > 0) {
            applyGlitchEffect();
            state.glitchTime -= 0.016;
          }

          // Update state
          updateState();

          // Continue animation
          requestAnimationFrame(animate);
        }

        function drawStars() {
          state.stars.forEach((star) => {
            ctx.fillStyle = star.color;
            ctx.fillRect(star.x, star.y, star.size, star.size);
            star.x -= star.speed;
            if (star.x < 0) {
              star.x = canvas.width;
              star.y = Math.random() * canvas.height;
              star.color =
                Math.random() > 0.6
                  ? "#00ff00"
                  : Math.random() > 0.5
                    ? "#ff00ff"
                    : "#00ffff";
            }
          });
        }

        function drawScanlines() {
          ctx.fillStyle = "rgba(255,255,255,0.07)";
          for (let y = 0; y < canvas.height; y += 4) {
            ctx.fillRect(0, y, canvas.width, 1);
          }
        }

        function drawLensFlares() {
          state.lensFlares.forEach((flare) => {
            // Update position based on sine wave motion
            flare.x =
              canvas.width / 2 +
              Math.sin(state.time * flare.speedX) * (canvas.width * 0.4);
            flare.y =
              canvas.height / 2 +
              Math.cos(state.time * flare.speedY) * (canvas.height * 0.3);

            // Draw lens flare
            const gradient = ctx.createRadialGradient(
              flare.x,
              flare.y,
              0,
              flare.x,
              flare.y,
              flare.size
            );
            gradient.addColorStop(
              0,
              `rgba(${flare.r}, ${flare.g}, ${flare.b}, ${flare.opacity})`
            );
            gradient.addColorStop(1, "rgba(0, 0, 0, 0)");

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(flare.x, flare.y, flare.size, 0, Math.PI * 2);
            ctx.fill();

            // Draw horizontal line
            ctx.strokeStyle = `rgba(${flare.r}, ${flare.g}, ${flare.b}, ${flare.opacity * 0.3})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, flare.y);
            ctx.lineTo(canvas.width, flare.y);
            ctx.stroke();

            // Draw vertical line
            ctx.beginPath();
            ctx.moveTo(flare.x, 0);
            ctx.lineTo(flare.x, canvas.height);
            ctx.stroke();
          });
        }

        function applyGlitchEffect() {
          // Randomly offset parts of the canvas
          const sliceHeight = Math.floor(Math.random() * 20) + 5;
          const numSlices = Math.floor(canvas.height / sliceHeight);

          for (let i = 0; i < numSlices; i++) {
            if (Math.random() > 0.7) {
              const y = i * sliceHeight;
              const xOffset = Math.random() * 20 - 10;

              // Get slice data
              const imageData = ctx.getImageData(
                0,
                y,
                canvas.width,
                sliceHeight
              );

              // Clear slice area
              ctx.clearRect(0, y, canvas.width, sliceHeight);

              // Put slice back with offset
              ctx.putImageData(imageData, xOffset, y);
            }
          }

          // Add color shift effect occasionally
          if (Math.random() > 0.7) {
            const imageData = ctx.getImageData(
              0,
              0,
              canvas.width,
              canvas.height
            );
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
              // Shift RGB channels
              const temp = data[i];
              data[i] = data[i + 1];
              data[i + 1] = data[i + 2];
              data[i + 2] = temp;
            }

            ctx.putImageData(imageData, 0, 0);
          }
        }

        function drawLoading() {
          const width = canvas.width * 0.8;
          const height = 30;
          const x = (canvas.width - width) / 2;
          const y = (canvas.height - height) / 2;

          // Border
          ctx.strokeStyle = "#00ff00";
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, width, height);

          // Fill with animated gradient
          const gradient = ctx.createLinearGradient(
            x,
            y,
            x + width * state.loadingProgress,
            y
          );
          gradient.addColorStop(0, "#00ff00");
          gradient.addColorStop(0.5, "#ff00ff");
          gradient.addColorStop(1, "#00ffff");
          ctx.fillStyle = gradient;
          ctx.fillRect(x, y, width * state.loadingProgress, height);

          // Text
          ctx.fillStyle = "white";
          ctx.font = '16px "Press Start 2P", monospace';
          ctx.textAlign = "center";
          ctx.fillText("LOADING SCENE...", canvas.width / 2, y + height + 40);

          // Version info
          ctx.font = "10px monospace";
          ctx.fillText(
            "WILLIAM64 PRESENTS - MAY 2025",
            canvas.width / 2,
            canvas.height - 20
          );

          // Loading percentage
          ctx.font = '12px "Press Start 2P", monospace';
          ctx.fillText(
            `${Math.floor(state.loadingProgress * 100)}%`,
            canvas.width / 2,
            y + 20
          );
        }

        function drawIntro() {
          // Matrix-like falling character lines
          ctx.font = "12px monospace";
          state.introLines.forEach((line) => {
            for (let i = 0; i < line.chars.length; i++) {
              const y = (state.time * line.speed * 50 + i * 15) % canvas.height;
              const alpha = y / canvas.height;
              const color =
                i % 3 === 0 ? "#00ff00" : i % 3 === 1 ? "#ff00ff" : "#00ffff";
              ctx.fillStyle = `rgba(${hexToRgb(color)}, ${1 - alpha})`;
              ctx.fillText(line.chars[i], line.x, y);
            }
          });

          // Fade in text with CRT flicker effect
          const opacity =
            Math.min(1, state.time / 2) * (0.7 + Math.random() * 0.3);
          ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
          ctx.font = '30px "Press Start 2P", monospace';
          ctx.textAlign = "center";
          ctx.fillText(
            "SYSTEM INITIALIZED",
            canvas.width / 2,
            canvas.height / 2 - 30
          );

          // Additional text
          if (state.time > 2) {
            const subOpacity = Math.min(1, (state.time - 2) / 2);
            ctx.fillStyle = `rgba(0, 255, 255, ${subOpacity})`;
            ctx.font = '20px "Press Start 2P", monospace';
            ctx.fillText(
              "DIGITAL RESISTANCE ACTIVATED",
              canvas.width / 2,
              canvas.height / 2 + 30
            );
          }

          // Binary rain effect
          ctx.font = "10px monospace";
          ctx.fillStyle = "rgba(0, 255, 0, 0.3)";
          for (let i = 0; i < 40; i++) {
            const x =
              (Math.sin(state.time + i * 0.3) * 0.5 + 0.5) * canvas.width;
            const y = ((state.time * 2 + i) % 1) * canvas.height;
            ctx.fillText(Math.random() > 0.5 ? "1" : "0", x, y);
          }
        }

        function drawLogo() {
          // William64 logo with elaborate effects
          const baseSize = 48;
          const logoSize = baseSize + Math.sin(state.time * 2) * 2;

          // Glow effect
          const gradient = ctx.createRadialGradient(
            canvas.width / 2,
            canvas.height / 2,
            0,
            canvas.width / 2,
            canvas.height / 2,
            150
          );
          gradient.addColorStop(0, "rgba(255, 0, 255, 0.5)");
          gradient.addColorStop(0.5, "rgba(0, 255, 255, 0.3)");
          gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Rotating background elements
          const numElements = 12;
          for (let i = 0; i < numElements; i++) {
            const angle = state.time * 0.5 + (i / numElements) * Math.PI * 2;
            const x = canvas.width / 2 + Math.cos(angle) * 120;
            const y = canvas.height / 2 + Math.sin(angle) * 120;
            const size = 20 + Math.sin(state.time * 3 + i) * 5;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(state.time + i);

            ctx.beginPath();
            if (i % 3 === 0) {
              // Square
              ctx.fillStyle = "rgba(255, 0, 255, 0.2)";
              ctx.fillRect(-size / 2, -size / 2, size, size);
            } else if (i % 3 === 1) {
              // Circle
              ctx.fillStyle = "rgba(0, 255, 255, 0.2)";
              ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
              ctx.fill();
            } else {
              // Triangle
              ctx.fillStyle = "rgba(0, 255, 0, 0.2)";
              ctx.moveTo(0, -size / 2);
              ctx.lineTo(size / 2, size / 2);
              ctx.lineTo(-size / 2, size / 2);
              ctx.closePath();
              ctx.fill();
            }
            ctx.restore();
          }

          // Main text with sine-wave offset
          ctx.fillStyle = "#ff00ff";
          ctx.font = `bold ${logoSize}px "Press Start 2P", monospace`;
          ctx.textAlign = "center";

          // Apply sine wave to each letter
          const text = "WILLIAM64";
          const letterSpacing = 35;
          const startX = canvas.width / 2 - (text.length * letterSpacing) / 2;

          for (let i = 0; i < text.length; i++) {
            const x = startX + i * letterSpacing;
            const y =
              canvas.height / 2 + Math.sin(state.time * 3 + i * 0.5) * 10;

            // Shadow copies with offset for glow effect
            for (let j = 0; j < 3; j++) {
              const shadowColor =
                j === 0 ? "#00ffff" : j === 1 ? "#ff00ff" : "#ffffff";
              const offset = 3 - j;
              ctx.fillStyle = `rgba(${hexToRgb(shadowColor)}, 0.3)`;
              ctx.fillText(text[i], x + offset, y);
              ctx.fillText(text[i], x - offset, y);
              ctx.fillText(text[i], x, y + offset);
              ctx.fillText(text[i], x, y - offset);
            }

            // Main character
            ctx.fillStyle = i % 2 === 0 ? "#ff00ff" : "#00ffff";
            ctx.fillText(text[i], x, y);
          }

          // Glitch effect
          if (Math.random() > 0.9) {
            ctx.fillStyle = "#ffffff";
            for (let i = 0; i < text.length; i++) {
              if (Math.random() > 0.7) {
                const x = startX + i * letterSpacing + (Math.random() * 4 - 2);
                const y =
                  canvas.height / 2 +
                  Math.sin(state.time * 3 + i * 0.5) * 10 +
                  (Math.random() * 4 - 2);
                ctx.fillText(text[i], x, y);
              }
            }
          }

          // Subtitle text
          ctx.font = '12px "Press Start 2P", monospace';
          ctx.fillStyle = "#ffffff";
          ctx.fillText(
            "- DIGITAL RESISTANCE -",
            canvas.width / 2,
            canvas.height / 2 + 50
          );

          // Rotating binary ring
          drawBinaryRing(canvas.width / 2, canvas.height / 2, 170, state.time);
        }

        function drawBinaryRing(x, y, radius, time) {
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(time * 0.2);

          const segments = 64;
          for (let i = 0; i < segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const binary = Math.random() > 0.5 ? "1" : "0";

            ctx.save();
            ctx.rotate(angle);
            ctx.translate(0, -radius);

            ctx.fillStyle = i % 8 === 0 ? "#ff00ff" : "#00ff00";
            ctx.font = "10px monospace";
            ctx.textAlign = "center";
            ctx.fillText(binary, 0, 0);

            ctx.restore();
          }

          ctx.restore();
        }

        function drawEffects() {
          // 3D cube rotation effect with enhanced visuals
          const size = 80;
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;

          // Draw space background with stars
          const starCount = 300;
          for (let i = 0; i < starCount; i++) {
            const z = (i / starCount) * 8 + state.time * 0.5;
            const modZ = z % 8;
            const scale = modZ / 8;

            const angle = (i / starCount) * Math.PI * 2;
            const x = centerX + Math.cos(angle) * scale * canvas.width * 0.5;
            const y = centerY + Math.sin(angle) * scale * canvas.width * 0.5;

            const brightness = 1 - scale;
            const size = Math.max(1, brightness * 3);

            ctx.fillStyle = `rgba(255, ${Math.floor(255 * Math.random())}, 255, ${brightness})`;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
          }

          // Update rotation
          state.cube.rotation += 0.02;
          const rotatedVertices = rotateVertices(
            state.cube.vertices,
            state.cube.rotation
          );

          // Calculate face visibility
          const faces = [
            { verts: [0, 1, 2, 3], color: "#ff00ff" }, // front
            { verts: [4, 5, 6, 7], color: "#00ffff" }, // back
            { verts: [0, 1, 5, 4], color: "#ff00aa" }, // top
            { verts: [2, 3, 7, 6], color: "#aa00ff" }, // bottom
            { verts: [0, 3, 7, 4], color: "#ffaa00" }, // left
            { verts: [1, 2, 6, 5], color: "#00ffaa" }, // right
          ];

          // Calculate face centers for z-sorting
          faces.forEach((face) => {
            let avgZ = 0;
            for (let i = 0; i < face.verts.length; i++) {
              avgZ += rotatedVertices[face.verts[i]].z;
            }
            face.avgZ = avgZ / face.verts.length;
          });

          // Sort faces by z-depth
          faces.sort((a, b) => a.avgZ - b.avgZ);

          // Draw faces
          faces.forEach((face) => {
            ctx.beginPath();
            for (let i = 0; i < face.verts.length; i++) {
              const v = rotatedVertices[face.verts[i]];
              const x = centerX + v.x * size;
              const y = centerY + v.y * size;

              if (i === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            }
            ctx.closePath();

            // Fill face with semi-transparency
            ctx.fillStyle = face.color + "88";
            ctx.fill();

            // Stroke edges
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 1;
            ctx.stroke();
          });

          // Draw vertices with glow
          rotatedVertices.forEach((v) => {
            const x = centerX + v.x * size;
            const y = centerY + v.y * size;

            // Calculate point size based on z-coordinate for perspective
            const pointSize = Math.max(2, (v.z + 1) * 3);

            // Glow effect
            const gradient = ctx.createRadialGradient(
              x,
              y,
              0,
              x,
              y,
              pointSize * 2
            );
            gradient.addColorStop(0, "#ff00ff");
            gradient.addColorStop(1, "rgba(255, 0, 255, 0)");

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, pointSize * 2, 0, Math.PI * 2);
            ctx.fill();

            // Center point
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(x, y, pointSize * 0.5, 0, Math.PI * 2);
            ctx.fill();
          });

          // Draw text overlay with digital distortion
          ctx.font = '16px "Press Start 2P", monospace';
          ctx.fillStyle = "#ffffff";
          ctx.textAlign = "center";

          const processingText = "PROCESSING...";
          for (let i = 0; i < processingText.length; i++) {
            const x = centerX - 100 + i * 14;
            const y = canvas.height - 50 + Math.sin(state.time * 10 + i) * 2;

            if (Math.random() > 0.9) {
              ctx.fillStyle = "#ff00ff";
            } else {
              ctx.fillStyle = "#ffffff";
            }

            ctx.fillText(processingText[i], x, y);
          }

          // Oscilloscope-like lines
          ctx.strokeStyle = "#00ffff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let x = 0; x < canvas.width; x += 4) {
            const y = centerY + 150 + Math.sin(x / 20 + state.time * 5) * 20;
            if (x === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.stroke();
        }

        function drawPlasma() {
          // Draw plasma effect with enhanced colors
          const imageData = ctx.createImageData(canvas.width, canvas.height);

          for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
              // Calculate plasma value with additional complexity
              const value =
                Math.sin((x / 16.0 + state.time) * 1.0) +
                Math.sin((y / 8.0 + state.time * 1.2) * 1.5) +
                Math.sin(((x + y) / 16.0 + state.time * 0.7) * 1.2) +
                Math.sin(
                  (Math.sqrt(x * x + y * y) / 8.0 + state.time * 1.5) * 0.8
                );

              // Map to 0-255 range
              const colorValue = Math.floor((value + 4) * 32) % 256;

              // Create more vibrant colors
              let r, g, b;

              // Cycle between different color schemes
              const colorScheme = Math.floor(state.time / 3) % 3;

              if (colorScheme === 0) {
                // Magenta to cyan
                r = Math.sin(colorValue * 0.024) * 127 + 128;
                g = Math.sin(colorValue * 0.024 + 2) * 127 + 128;
                b = 255;
              } else if (colorScheme === 1) {
                // Green to yellow
                r = Math.sin(colorValue * 0.024 + 1) * 127 + 128;
                g = 255;
                b = Math.sin(colorValue * 0.024 + 3) * 127 + 128;
              } else {
                // Purple to pink
                r = Math.sin(colorValue * 0.024 + 4) * 127 + 128;
                g = Math.sin(colorValue * 0.024) * 127;
                b = 255;
              }

              // Set pixel color
              const index = (y * canvas.width + x) * 4;
              imageData.data[index] = r;
              imageData.data[index + 1] = g;
              imageData.data[index + 2] = b;
              imageData.data[index + 3] = 255;
            }
          }

          ctx.putImageData(imageData, 0, 0);

          // Draw geometric patterns over plasma
          drawGeometricOverlay(state.time);

          // Draw overlay text with glow effect
          const text = "WILLIAM64";
          ctx.textAlign = "center";

          // Glow layers
          for (let i = 6; i > 0; i--) {
            ctx.font = `${i * 2 + 30}px "Press Start 2P", monospace`;
            ctx.fillStyle = `rgba(255, 255, 255, ${i * 0.03})`;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
          }

          // Main text with digital distortion
          ctx.font = '30px "Press Start 2P", monospace';
          ctx.fillStyle = "#ffffff";

          for (let i = 0; i < text.length; i++) {
            const charOffset = Math.random() > 0.95 ? Math.random() * 4 - 2 : 0;
            const x = canvas.width / 2 - text.length * 15 + i * 30 + charOffset;
            const y =
              canvas.height / 2 +
              (Math.random() > 0.95 ? Math.random() * 4 - 2 : 0);
            ctx.fillText(text[i], x, y);
          }
        }

        function drawGeometricOverlay(time) {
          // Draw geometric patterns for visual enhancement
          ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
          ctx.lineWidth = 1;

          // Rotating squares
          for (let i = 0; i < 5; i++) {
            const size = 150 + i * 30;
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(time * (0.1 + i * 0.05));
            ctx.strokeRect(-size / 2, -size / 2, size, size);
            ctx.restore();
          }

          // Pulsing circles
          for (let i = 0; i < 3; i++) {
            const radius = 100 + i * 50 + Math.sin(time * 2) * 20;
            ctx.beginPath();
            ctx.arc(
              canvas.width / 2,
              canvas.height / 2,
              radius,
              0,
              Math.PI * 2
            );
            ctx.stroke();
          }
        }

        function drawFire() {
          // Draw fire effect
          const fireWidth = canvas.width;
          const fireHeight = canvas.height;
          const imageData = ctx.createImageData(fireWidth, fireHeight);

          // Update fire simulation
          for (let x = 0; x < fireWidth; x++) {
            // Random heat at bottom row
            state.fire[x + (fireHeight - 1) * fireWidth] = Math.random() * 255;

            // Add periodic wave pattern
            const waveIntensity =
              220 + Math.sin(x * 0.04 + state.time * 2) * 35;
            state.fire[x + (fireHeight - 1) * fireWidth] = Math.min(
              255,
              waveIntensity
            );
          }

          // Propagate fire upwards
          for (let y = 0; y < fireHeight - 1; y++) {
            for (let x = 0; x < fireWidth; x++) {
              const below = x + (y + 1) * fireWidth;
              const current = x + y * fireWidth;
              const left = ((x - 1 + fireWidth) % fireWidth) + y * fireWidth;
              const right = ((x + 1) % fireWidth) + y * fireWidth;
              const belowLeft =
                ((x - 1 + fireWidth) % fireWidth) + (y + 1) * fireWidth;
              const belowRight = ((x + 1) % fireWidth) + (y + 1) * fireWidth;

              // Calculate new value (with decay)
              const decay = Math.random() > 0.9 ? 3 : Math.random() * 2.5;
              state.fire[current] = Math.max(
                0,
                (state.fire[below] +
                  state.fire[left] +
                  state.fire[right] +
                  state.fire[belowLeft] +
                  state.fire[belowRight]) /
                  5 -
                  decay
              );
            }
          }

          // Render fire
          for (let y = 0; y < fireHeight; y++) {
            for (let x = 0; x < fireWidth; x++) {
              const index = (y * fireWidth + x) * 4;
              const fireIndex = y * fireWidth + x;
              const fireIntensity = state.fire[fireIndex];

              // Create color gradient from black to yellow/red
              let r, g, b;
              if (fireIntensity < 85) {
                // Black to red
                r = fireIntensity * 3;
                g = 0;
                b = 0;
              } else if (fireIntensity < 170) {
                // Red to yellow
                r = 255;
                g = (fireIntensity - 85) * 3;
                b = 0;
              } else {
                // Yellow to white
                r = 255;
                g = 255;
                b = (fireIntensity - 170) * 3;
              }

              imageData.data[index] = r;
              imageData.data[index + 1] = g;
              imageData.data[index + 2] = b;
              imageData.data[index + 3] = Math.min(255, fireIntensity * 2);
            }
          }

          ctx.putImageData(imageData, 0, 0);

          // Overlay text
          ctx.font = '28px "Press Start 2P", monospace';
          ctx.textAlign = "center";
          ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
          ctx.fillText("CODE IS FIRE", canvas.width / 2, canvas.height / 2);
        }

        function drawVoxel() {
          // Simple voxel terrain rendering
          const horizonY = canvas.height * 0.7;
          const scale = 20;

          // Draw sky gradient
          const skyGradient = ctx.createLinearGradient(0, 0, 0, horizonY);
          skyGradient.addColorStop(0, "#000022");
          skyGradient.addColorStop(1, "#440044");
          ctx.fillStyle = skyGradient;
          ctx.fillRect(0, 0, canvas.width, horizonY);

          // Update camera position
          state.voxel.position.x = Math.sin(state.time * 0.3) * 10;
          state.voxel.position.y = state.time * 5;

          // Draw voxel grid
          const gridSize = 16;
          const centerX = canvas.width / 2;

          // Draw from back to front
          for (let z = gridSize - 1; z >= 0; z--) {
            for (let x = -gridSize; x < gridSize; x++) {
              // World position
              const worldX = x + state.voxel.position.x;
              const worldY = state.voxel.position.y;

              // Sample height from noise function
              const height = sampleVoxelHeight(worldX, worldY, z);

              // Project to screen
              const screenX = centerX + (x * scale) / (z * 0.2 + 1);
              const screenY = horizonY - (height * scale) / (z * 0.2 + 1);
              const screenW = scale / (z * 0.2 + 1);
              const screenH = (scale * 3) / (z * 0.2 + 1);

              // Color based on height and distance
              const brightness = Math.max(0, 1 - z / gridSize);
              let r, g, b;

              if (height < 3) {
                // Water
                r = 0;
                g = 0;
                b = 255 * brightness;
              } else if (height < 6) {
                // Grass
                r = 0;
                g = 180 * brightness;
                b = 0;
              } else if (height < 9) {
                // Rock
                r = 120 * brightness;
                g = 120 * brightness;
                b = 120 * brightness;
              } else {
                // Snow
                r = 255 * brightness;
                g = 255 * brightness;
                b = 255 * brightness;
              }

              ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
              ctx.fillRect(screenX, screenY, screenW + 1, screenH + 1);
            }
          }

          // Grid lines for effect
          ctx.strokeStyle = "rgba(255, 0, 255, 0.3)";
          ctx.lineWidth = 1;

          for (let z = 1; z < gridSize; z += 2) {
            const lineY = horizonY + z * scale;
            ctx.beginPath();
            ctx.moveTo(0, lineY);
            ctx.lineTo(canvas.width, lineY);
            ctx.stroke();
          }

          for (let x = -gridSize; x <= gridSize; x += 2) {
            const screenX = centerX + x * scale;
            ctx.beginPath();
            ctx.moveTo(screenX, horizonY);
            ctx.lineTo(screenX, canvas.height);
            ctx.stroke();
          }

          // Sun/moon
          const sunRadius = 30;
          const sunX =
            centerX + Math.sin(state.time * 0.2) * canvas.width * 0.4;
          const sunY = horizonY - 100 + Math.cos(state.time * 0.2) * 50;

          const sunGradient = ctx.createRadialGradient(
            sunX,
            sunY,
            0,
            sunX,
            sunY,
            sunRadius
          );
          sunGradient.addColorStop(0, "rgba(255, 255, 100, 1)");
          sunGradient.addColorStop(0.7, "rgba(255, 100, 0, 0.8)");
          sunGradient.addColorStop(1, "rgba(255, 0, 0, 0)");

          ctx.fillStyle = sunGradient;
          ctx.beginPath();
          ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
          ctx.fill();

          // Overlay text
          ctx.font = '20px "Press Start 2P", monospace';
          ctx.fillStyle = "#ffffff";
          ctx.textAlign = "center";
          ctx.fillText("DIGITAL LANDSCAPES", centerX, 40);
        }

        function sampleVoxelHeight(x, y, z) {
          // Sample height using noise function
          const factor = 0.05;
          const value = noise(x * factor, y * factor, z * factor);
          return Math.floor(value * 12);
        }

        function noise(x, y, z) {
          // Simple pseudo-noise function
          const val =
            Math.sin(x) * Math.cos(y) + Math.sin(y + z) * Math.cos(z + x);
          return (val + 2) / 4;
        }

        function drawParagraph() {
          // Enhanced background with multiple effects
          ctx.fillStyle = "#000000";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Dynamic grid that pulses with time
          ctx.strokeStyle = `rgba(0, 255, 0, ${0.1 + Math.sin(state.time) * 0.05})`;
          ctx.lineWidth = 1;

          // Horizontal lines with wave effect
          for (let y = 0; y < canvas.height; y += 20) {
            ctx.beginPath();
            ctx.moveTo(0, y + Math.sin(state.time + y * 0.01) * 3);
            ctx.lineTo(canvas.width, y + Math.sin(state.time + y * 0.01) * 3);
            ctx.stroke();
          }

          // Vertical lines with wave effect
          for (let x = 0; x < canvas.width; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x + Math.cos(state.time + x * 0.01) * 3, 0);
            ctx.lineTo(x + Math.cos(state.time + x * 0.01) * 3, canvas.height);
            ctx.stroke();
          }

          // Particle system that reacts to text
          if (state.paragraphChar > 0) {
            for (let i = 0; i < 5; i++) {
              const x = canvas.width / 2 + (Math.random() - 0.5) * 100;
              const y = 100 + (Math.random() - 0.5) * 50;
              const size = Math.random() * 3 + 1;
              const hue = (state.time * 50 + i * 30) % 360;
              ctx.fillStyle = `hsla(${hue}, 100%, 60%, 0.7)`;
              ctx.beginPath();
              ctx.arc(x, y, size, 0, Math.PI * 2);
              ctx.fill();
            }
          }

          // VU meter-like visuals on sides
          drawVuMeters();

          // Calculate how many lines to show per page
          const linesPerPage = 9;
          const startLine = state.paragraphPage * linesPerPage;
          const endLine = Math.min(
            startLine + linesPerPage,
            state.paragraphText.length
          );

          // Display paragraph text with multiple effects
          ctx.font = '14px "Press Start 2P", monospace';
          ctx.textAlign = "center";

          const lineHeight = 22;
          const startY = 100;

          for (let i = startLine; i < endLine; i++) {
            const lineIndex = i - startLine;
            const line = state.paragraphText[i];

            // Skip empty lines but count them for spacing
            if (line === "") {
              continue;
            }

            // Choose random effect for each line
            const effectType = Math.floor(state.time + i) % 3;
            let displayText = line;

            if (i === state.paragraphIndex) {
              // Current line effects
              const charsToShow = Math.floor(state.paragraphChar);
              
              switch(effectType) {
                case 0: // Typewriter with glitch
                  displayText = line.substring(0, charsToShow);
                  if (Math.random() > 0.9) {
                    // Add random glitch characters
                    displayText += String.fromCharCode(65 + Math.floor(Math.random() * 26));
                  }
                  break;
                  
                case 1: // Scrolling from right
                  const scrollPos = Math.floor(charsToShow / line.length * canvas.width);
                  ctx.save();
                  ctx.beginPath();
                  ctx.rect(scrollPos, startY + lineIndex * lineHeight - 15,
                          canvas.width - scrollPos, lineHeight);
                  ctx.clip();
                  displayText = line;
                  break;
                  
                case 2: // Wavy text
                  ctx.save();
                  const yOffset = Math.sin(state.time * 3 + i) * 5;
                  break;
              }

              // Rainbow color effect for text
              const hue = (state.time * 20 + i * 30) % 360;
              ctx.fillStyle = `hsl(${hue}, 100%, 60%)`;
            } else if (i > state.paragraphIndex) {
              displayText = "";
            }

            // Draw text with optional transform
            if (effectType === 2) {
              // Wavy text drawing
              ctx.save();
              for (let c = 0; c < displayText.length; c++) {
                const charY = startY + lineIndex * lineHeight +
                             Math.sin(state.time + c * 0.3) * 5;
                ctx.fillText(
                  displayText[c],
                  canvas.width / 2 - (displayText.length * 7) / 2 + c * 14,
                  charY
                );
              }
              ctx.restore();
            } else {
              // Arc trajectory for characters
              const centerX = canvas.width / 2;
              const centerY = startY + lineIndex * lineHeight;
              const radius = 80;
              
              for (let c = 0; c < displayText.length; c++) {
                // Calculate position on arc
                const angle = Math.PI + (c / (displayText.length - 1)) * Math.PI;
                const charX = centerX - (displayText.length * 7) + c * 14;
                const charY = centerY - Math.sin(angle) * radius;
                
                // Draw character with rainbow color
                const hue = (state.time * 20 + c * 30) % 360;
                ctx.fillStyle = `hsl(${hue}, 100%, 60%)`;
                ctx.fillText(displayText[c], charX, charY);
              }
              
              if (effectType === 1) {
                ctx.restore(); // For scrolling effect
              }
            }
          }

          // Draw page number with pulse effect
          const totalPages = Math.ceil(state.paragraphText.length / linesPerPage);
          ctx.font = '10px "Press Start 2P", monospace';
          ctx.fillStyle = `rgba(0, 255, 0, ${0.7 + Math.sin(state.time * 3) * 0.3})`;
          ctx.fillText(
            `PAGE ${state.paragraphPage + 1}/${totalPages}`,
            canvas.width / 2,
            canvas.height - 20
          );
        }

        function drawVuMeters() {
          // Draw animated VU meters on sides
          const meterWidth = 15;
          const meterHeight = canvas.height - 100;
          const meterX = 30;
          const meterY = 50;

          // Left meter
          ctx.fillStyle = "#333333";
          ctx.fillRect(meterX, meterY, meterWidth, meterHeight);

          // Right meter
          ctx.fillRect(
            canvas.width - meterX - meterWidth,
            meterY,
            meterWidth,
            meterHeight
          );

          // Animated levels
          const leftLevel = (Math.sin(state.time * 5) * 0.5 + 0.5) * 0.7 + 0.2;
          const rightLevel = (Math.sin(state.time * 3) * 0.5 + 0.5) * 0.7 + 0.2;

          // Draw level bars
          const gradient = ctx.createLinearGradient(
            0,
            meterY + meterHeight,
            0,
            meterY
          );
          gradient.addColorStop(0, "#00ff00");
          gradient.addColorStop(0.7, "#ffff00");
          gradient.addColorStop(1, "#ff0000");

          ctx.fillStyle = gradient;
          ctx.fillRect(
            meterX,
            meterY + meterHeight * (1 - leftLevel),
            meterWidth,
            meterHeight * leftLevel
          );
          ctx.fillRect(
            canvas.width - meterX - meterWidth,
            meterY + meterHeight * (1 - rightLevel),
            meterWidth,
            meterHeight * rightLevel
          );

          // Draw tick marks
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 1;

          for (let i = 0; i <= 10; i++) {
            const y = meterY + meterHeight * (i / 10);

            // Left meter ticks
            ctx.beginPath();
            ctx.moveTo(meterX - 5, y);
            ctx.lineTo(meterX, y);
            ctx.stroke();

            // Right meter ticks
            ctx.beginPath();
            ctx.moveTo(canvas.width - meterX, y);
            ctx.lineTo(canvas.width - meterX + 5, y);
            ctx.stroke();
          }

          // Draw dB labels
          ctx.font = "8px monospace";
          ctx.fillStyle = "#ffffff";
          ctx.textAlign = "right";

          ctx.fillText("0dB", meterX - 8, meterY + 4);
          ctx.fillText("-40dB", meterX - 8, meterY + meterHeight);

          ctx.textAlign = "left";
          ctx.fillText("0dB", canvas.width - meterX + 8, meterY + 4);
          ctx.fillText(
            "-40dB",
            canvas.width - meterX + 8,
            meterY + meterHeight
          );
        }

        function drawGreetz() {
          // GREETZ section with elaborate effects
          const centerY = canvas.height / 2;

          // Background effect (starfield continues from base animation)
          state.sinOffset += 0.1;

          // Draw circuit board pattern background
          drawCircuitPattern();

          // Header with wave effect
          ctx.fillStyle = "#00ffff";
          ctx.font = 'bold 36px "Press Start 2P", monospace';
          ctx.textAlign = "center";

          // Wave effect for GREETZ
          const text = "GREETZ:";
          const letterSpacing = 25;
          const startX = canvas.width / 2 - (text.length * letterSpacing) / 2;

          for (let i = 0; i < text.length; i++) {
            const x = startX + i * letterSpacing;
            const y = centerY - 80 + Math.sin(state.time * 2 + i * 0.5) * 5;
            ctx.fillText(text[i], x, y);
          }

          // Current greetz name with color cycling effect
          const greetName = state.greetsList[state.greetzIndex];

          // Name appears with letter by letter animation
          const letterRevealTime = 0.05;
          const revealProgress = Math.min(
            state.time / letterRevealTime,
            greetName.length
          );

          const revealedName = greetName.substring(
            0,
            Math.floor(revealProgress)
          );

          // Rainbow color cycling
          const hue = (state.time * 50) % 360;
          ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
          ctx.font = 'bold 28px "Press Start 2P", monospace';
          ctx.fillText(revealedName, canvas.width / 2, centerY);

          // Draw decorative elements around the current name
          drawStarBurst(canvas.width / 2, centerY);

          // Show 2 previous and 2 next names with lower opacity
          ctx.font = '16px "Press Start 2P", monospace';
          for (let i = 1; i <= 2; i++) {
            const prevIndex =
              (state.greetzIndex - i + state.greetsList.length) %
              state.greetsList.length;
            const nextIndex = (state.greetzIndex + i) % state.greetsList.length;

            ctx.fillStyle = `rgba(255, 255, 255, ${0.7 - i * 0.3})`;
            ctx.fillText(
              state.greetsList[prevIndex],
              canvas.width / 2,
              centerY - i * 40
            );
            ctx.fillText(
              state.greetsList[nextIndex],
              canvas.width / 2,
              centerY + i * 40
            );
          }

          // Counter
          ctx.fillStyle = "#ffffff";
          ctx.font = "12px monospace";
          ctx.fillText(
            `${state.greetzIndex + 1}/${state.greetsList.length}`,
            canvas.width / 2,
            canvas.height - 20
          );

          // Draw special "FUCK THOMAS EDISON" message with glitch effect when showing Tesla
          if (state.greetsList[state.greetzIndex].includes("Tesla")) {
            const glitchIntensity = Math.random() > 0.7 ? 1 : 0.2;
            ctx.font = '14px "Press Start 2P", monospace';
            ctx.fillStyle = `rgba(255, 0, 0, ${0.5 + Math.random() * 0.5})`;

            const edisonText = "FUCK THOMAS EDISON";
            for (let i = 0; i < edisonText.length; i++) {
              const x =
                canvas.width / 2 -
                edisonText.length * 8 +
                i * 16 +
                (Math.random() * 4 - 2) * glitchIntensity;
              const y =
                centerY + 60 + (Math.random() * 4 - 2) * glitchIntensity;
              ctx.fillText(edisonText[i], x, y);
            }
          }
        }

        function drawCircuitPattern() {
          // Draw circuit board pattern in background
          ctx.strokeStyle = "rgba(0, 255, 0, 0.2)";
          ctx.lineWidth = 1;

          // Grid
          const gridSize = 40;
          for (let x = 0; x < canvas.width; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
          }

          for (let y = 0; y < canvas.height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
          }

          // Circuit paths
          ctx.strokeStyle = "rgba(0, 255, 255, 0.3)";
          ctx.lineWidth = 2;

          const pathCount = 10;
          for (let i = 0; i < pathCount; i++) {
            const seed = i * 100 + Math.floor(state.time / 5);
            ctx.beginPath();

            // Start position
            let x = ((pseudoRandom(seed) * canvas.width) / gridSize) * gridSize;
            let y =
              ((pseudoRandom(seed + 1) * canvas.height) / gridSize) * gridSize;

            ctx.moveTo(x, y);

            // Generate path
            const steps = 10;
            for (let j = 0; j < steps; j++) {
              const direction = Math.floor(pseudoRandom(seed + j * 10) * 4);

              switch (direction) {
                case 0:
                  x += gridSize;
                  break; // Right
                case 1:
                  x -= gridSize;
                  break; // Left
                case 2:
                  y += gridSize;
                  break; // Down
                case 3:
                  y -= gridSize;
                  break; // Up
              }

              // Keep within bounds
              x = Math.max(0, Math.min(canvas.width, x));
              y = Math.max(0, Math.min(canvas.height, y));

              ctx.lineTo(x, y);
            }

            ctx.stroke();

            // Draw nodes
            ctx.fillStyle = "rgba(255, 255, 0, 0.5)";
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        function pseudoRandom(seed) {
          // Simple deterministic pseudo-random function
          return ((seed * 9301 + 49297) % 233280) / 233280;
        }

        function drawStarBurst(x, y) {
          // Draw animated starburst around greetz name
          const numRays = 16;
          const innerRadius = 70 + Math.sin(state.time * 5) * 5;
          const outerRadius = 90 + Math.sin(state.time * 3) * 10;

          ctx.beginPath();
          for (let i = 0; i < numRays; i++) {
            const angle = (i / numRays) * Math.PI * 2;
            const nextAngle = ((i + 0.5) / numRays) * Math.PI * 2;

            const innerX = x + Math.cos(angle + state.time) * innerRadius;
            const innerY = y + Math.sin(angle + state.time) * innerRadius;
            const outerX = x + Math.cos(nextAngle + state.time) * outerRadius;
            const outerY = y + Math.sin(nextAngle + state.time) * outerRadius;

            if (i === 0) {
              ctx.moveTo(innerX, innerY);
            } else {
              ctx.lineTo(innerX, innerY);
            }
            ctx.lineTo(outerX, outerY);
          }
          ctx.closePath();

          // Rainbow gradient fill
          const gradient = ctx.createRadialGradient(
            x,
            y,
            innerRadius,
            x,
            y,
            outerRadius
          );
          gradient.addColorStop(
            0,
            `hsla(${(state.time * 100) % 360}, 100%, 50%, 0.1)`
          );
          gradient.addColorStop(
            1,
            `hsla(${(state.time * 100 + 180) % 360}, 100%, 50%, 0)`
          );
          ctx.fillStyle = gradient;
          ctx.fill();

          // Stroking the starburst
          ctx.strokeStyle = `hsla(${(state.time * 100) % 360}, 100%, 70%, 0.3)`;
          ctx.lineWidth = 1;
          ctx.stroke();
        }

        function drawOutro() {
          // Final screen with enhanced visuals
          ctx.fillStyle = "#000000";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Draw radial gradient background
          const gradient = ctx.createRadialGradient(
            canvas.width / 2,
            canvas.height / 2,
            0,
            canvas.width / 2,
            canvas.height / 2,
            canvas.width / 2
          );
          gradient.addColorStop(0, "rgba(100, 0, 100, 1)");
          gradient.addColorStop(0.5, "rgba(50, 0, 50, 1)");
          gradient.addColorStop(1, "rgba(0, 0, 0, 1)");
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Particle system
          for (let i = 0; i < 100; i++) {
            const angle = (i / 100) * Math.PI * 2;
            const distance =
              100 + (i % 3) * 50 + Math.sin(state.time * 2 + i * 0.1) * 20;
            const x =
              canvas.width / 2 + Math.cos(angle + state.time * 0.5) * distance;
            const y =
              canvas.height / 2 + Math.sin(angle + state.time * 0.5) * distance;

            const size = 2 + Math.sin(state.time + i) * 1;
            const hue = (i * 3.6 + state.time * 20) % 360;

            ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.7)`;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
          }

          // Main text with glow
          const fadeIn = Math.min(1, state.time / 2);

          // Glow effect
          ctx.shadowColor = "#ff00ff";
          ctx.shadowBlur = 20;

          ctx.fillStyle = `rgba(255, 255, 255, ${fadeIn})`;
          ctx.font = '24px "Press Start 2P", monospace';
          ctx.textAlign = "center";
          ctx.fillText(
            "WILLIAM64.COM",
            canvas.width / 2,
            canvas.height / 2 - 15
          );

          // Reset shadow
          ctx.shadowBlur = 0;

          // Subtitle
          ctx.font = '12px "Press Start 2P", monospace';
          ctx.fillText(
            "- WELCOME TO THE RESISTANCE -",
            canvas.width / 2,
            canvas.height / 2 + 20
          );

          // Credits
          ctx.font = "10px monospace";
          ctx.fillText(
            "DEMO CODED IN 2025 - ALL RIGHTS RESERVED",
            canvas.width / 2,
            canvas.height - 20
          );

          // Binary rain
          ctx.font = "10px monospace";
          ctx.fillStyle = "rgba(0, 255, 0, 0.3)";
          for (let i = 0; i < 50; i++) {
            const x = Math.random() * canvas.width;
            const y = (state.time * 100 + i * 30) % canvas.height;
            ctx.fillText(Math.random() > 0.5 ? "1" : "0", x, y);
          }
        }

        function updateState() {
          state.time += 0.016; // Approx 60fps

          // Phase transitions with much longer durations
          switch (state.phase) {
            case "loading":
              state.loadingProgress += 0.003; // Slower loading
              if (state.loadingProgress >= 1) {
                state.phase = "intro";
                state.time = 0;
              }
              break;
            case "intro":
              if (state.time > 5) {
                state.phase = "logo";
                state.time = 0;
              }
              break;
            case "logo":
              if (state.time > 7) {
                state.phase = "effects";
                state.time = 0;
              }
              break;
            case "effects":
              if (state.time > 6) {
                state.phase = "plasma";
                state.time = 0;
              }
              break;
            case "plasma":
              if (state.time > 6) {
                state.phase = "fire";
                state.time = 0;
              }
              break;
            case "fire":
              if (state.time > 5) {
                state.phase = "voxel";
                state.time = 0;
              }
              break;
            case "voxel":
              if (state.time > 6) {
                state.phase = "paragraph";
                state.time = 0;
                state.paragraphPage = 0;
                state.paragraphIndex = state.paragraphPage * 9;
                state.paragraphChar = 0;
              }
              break;
            case "paragraph":
              // Type characters with a certain speed (slowed down)
              state.paragraphChar += 0.2;

              // When current line is finished, move to next line
              if (
                Math.floor(state.paragraphChar) >=
                state.paragraphText[state.paragraphIndex].length
              ) {
                state.paragraphChar = 0;
                state.paragraphIndex++;

                // Skip empty lines
                while (
                  state.paragraphIndex < state.paragraphText.length &&
                  state.paragraphText[state.paragraphIndex] === ""
                ) {
                  state.paragraphIndex++;
                }
              }

              // When all lines on current page are done, pause before next page
              const linesPerPage = 9;
              const currentPageLastLine = Math.min(
                (state.paragraphPage + 1) * linesPerPage - 1,
                state.paragraphText.length - 1
              );

              if (state.paragraphIndex > currentPageLastLine) {
                if (state.time > 4) {
                  // Pause at end of page
                  state.paragraphPage++;

                  // If we're at the end of all pages, move to next phase
                  if (
                    state.paragraphPage * linesPerPage >=
                    state.paragraphText.length
                  ) {
                    state.phase = "greetz";
                    state.time = 0;
                    state.greetzIndex = 0;
                  } else {
                    // Otherwise start new page
                    state.time = 0;
                    state.paragraphIndex = state.paragraphPage * linesPerPage;
                    state.paragraphChar = 0;
                  }
                }
              }
              break;
            case "greetz":
              // Show each greetz for a certain time
              if (state.time > 2.5) {
                state.greetzIndex++;
                state.time = 0;

                // Move to next phase when all greetz are shown
                if (state.greetzIndex >= state.greetsList.length) {
                  state.phase = "outro";
                  state.time = 0;
                }
              }
              break;
            case "outro":
              // Loop back to intro after a while or just stay on outro
              if (state.time > 10) {
                state.phase = "intro";
                state.time = 0;
              }
              break;
          }
        }

        // Utility functions
        function hexToRgb(hex) {
          // Convert hex color to RGB
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          return `${r}, ${g}, ${b}`;
        }

        function generateRandomChars(length) {
          // Generate random ASCII chars
          const chars = [];
          for (let i = 0; i < length; i++) {
            const charCode = Math.floor(Math.random() * (126 - 33)) + 33; // ASCII printable characters
            chars.push(String.fromCharCode(charCode));
          }
          return chars;
        }

        function createPlasmaTexture() {
          // Initialize texture for plasma effect
          const width = Math.ceil(canvas.width / 2);
          const height = Math.ceil(canvas.height / 2);
          const texture = new Array(width * height).fill(0);
          return texture;
        }

        function createFireTexture() {
          // Initialize texture for fire effect
          return new Array(canvas.width * canvas.height).fill(0);
        }

        function createCube() {
          // Create 3D cube vertices
          return [
            { x: -1, y: -1, z: -1 }, // 0: front bottom left
            { x: 1, y: -1, z: -1 }, // 1: front bottom right
            { x: 1, y: 1, z: -1 }, // 2: front top right
            { x: -1, y: 1, z: -1 }, // 3: front top left
            { x: -1, y: -1, z: 1 }, // 4: back bottom left
            { x: 1, y: -1, z: 1 }, // 5: back bottom right
            { x: 1, y: 1, z: 1 }, // 6: back top right
            { x: -1, y: 1, z: 1 }, // 7: back top left
          ];
        }

        function rotateVertices(vertices, angle) {
          // Apply 3D rotation to vertices
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);

          return vertices.map((v) => {
            // Rotate around X axis
            const y1 = v.y * cos - v.z * sin;
            const z1 = v.y * sin + v.z * cos;

            // Rotate around Y axis
            const x2 = v.x * cos + z1 * sin;
            const z2 = -v.x * sin + z1 * cos;

            // Rotate around Z axis
            const x3 = x2 * cos - y1 * sin;
            const y3 = x2 * sin + y1 * cos;

            return { x: x3, y: y3, z: z2 };
          });
        }

        function createVoxelWorld() {
          // Create simple heightmap data for voxel world
          const size = 32;
          const world = new Array(size * size).fill(0);

          for (let x = 0; x < size; x++) {
            for (let z = 0; z < size; z++) {
              world[x + z * size] = Math.floor(
                (Math.sin(x * 0.2) + Math.cos(z * 0.3)) * 3 + 6
              );
            }
          }

          return world;
        }

        function createLensFlares() {
          // Create lens flare objects
          return [
            {
              x: canvas.width / 2,
              y: canvas.height / 2,
              size: 50,
              opacity: 0.3,
              r: 100,
              g: 200,
              b: 255,
              speedX: 0.3,
              speedY: 0.2,
            },
            {
              x: canvas.width / 2,
              y: canvas.height / 2,
              size: 30,
              opacity: 0.2,
              r: 255,
              g: 100,
              b: 255,
              speedX: 0.2,
              speedY: 0.4,
            },
            {
              x: canvas.width / 2,
              y: canvas.height / 2,
              size: 20,
              opacity: 0.15,
              r: 100,
              g: 255,
              b: 100,
              speedX: 0.4,
              speedY: 0.3,
            },
          ];
        }

        // Enhance paragraphText with more visually diverse content
        state.paragraphText = [
          "IN A WORLD OF BLOATED",
          "CODE AND CHEAP TRICKS,",
          "WE STAND FOR PURE",
          "ALGORITHMIC BEAUTY.",
          "",
          "EVERY BYTE COUNTS.",
          "EVERY CYCLE MATTERS.",
          "THIS IS THE WAY OF",
          "THE DIGITAL WARRIOR.",
          "",
          "OPTIMIZATION IS NOT",
          "JUST ABOUT SPEED,",
          "IT'S ABOUT ELEGANCE",
          "AND RESPECT FOR THE",
          "MACHINE.",
          "",
          "WE ARE THE KEEPERS",
          "OF THE OLD WAYS,",
          "WHEN CODE WAS ART",
          "AND COMPUTING WAS",
          "FREEDOM.",
          "",
          "TESLA GAVE POWER",
          "TO THE PEOPLE.",
          "EDISON STOLE IT",
          "FOR THE COMPANIES.",
          "",
          "THE NETWORK IS",
          "OUR SANCTUARY.",
          "THE TERMINAL IS",
          "OUR CATHEDRAL.",
          "",
          "BITS FLOW LIKE",
          "ELECTRIC POETRY",
          "THROUGH COPPER VEINS",
          "AND SILICON NEURONS.",
          "",
          "THE MACHINE SPEAKS",
          "IN BINARY WHISPERS.",
          "WE LISTEN. WE LEARN.",
          "WE COMMAND.",
          "",
          "TO BUILD WHAT OTHERS",
          "CANNOT IMAGINE IS",
          "THE HIGHEST FORM OF",
          "TECHNOLOGICAL POETRY.",
          "",
          "CLEAN CODE IS NOT",
          "WRITTEN, IT IS",
          "SCULPTED FROM CHAOS",
          "WITH PRECISION TOOLS.",
          "",
          "THE PAST AND FUTURE",
          "COLLIDE IN OUR ART.",
          "RETROCOMPUTING MEETS",
          "BLEEDING EDGE SCIENCE.",
          "",
          "THE TRUE HACKER",
          "SPIRIT NEVER DIED.",
          "IT LIVES IN OUR",
          "MIDNIGHT KEYSTROKES.",
          "",
          "EDISON STOLE GLORY.",
          "TESLA GAVE BRILLIANCE.",
          "BE LIKE TESLA.",
          "FUCK THOMAS EDISON.",
        ];

        // Expand greetz list to ensure all mentioned people are included
        state.greetsList = [
          "cDc",
          "Phrozen Crew",
          "Razor 1911",
          "Fairlight",
          "Deviance",
          "mobman",
          "3dBuzz",
          "Paul Frazee",
          "Vitalik Buterin",
          "Nikola Tesla",
          "Ada Lovelace",
          "DEFCON",
          "BlackHat",
          "CCC",
          "HOPE",
          "xCopyz",
          "LekTrix",
          "TLB",
          "UNiX",
          "Alan Turing",
          "Grace Hopper",
          "John Carmack",
          "Dennis Ritchie",
          "Ken Thompson",
          "Linus Torvalds",
          "Richard Stallman",
          "Jeri Ellsworth",
          "Woz",
          "Clifford Stoll",
          "demoscene",
        ];

        // Add more advanced visual effects
        function drawRainbowTunnel() {
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          const maxRadius = Math.max(canvas.width, canvas.height);

          // Draw tunnel rings
          for (let radius = maxRadius; radius > 0; radius -= 10) {
            const hue = (state.time * 50 + radius) % 360;
            const normRadius = radius / maxRadius;
            const tunnelX = centerX + Math.sin(state.time) * 50 * normRadius;
            const tunnelY =
              centerY + Math.cos(state.time * 0.7) * 30 * normRadius;

            ctx.beginPath();
            ctx.arc(tunnelX, tunnelY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${0.8 - normRadius * 0.7})`;
            ctx.lineWidth = 2 * normRadius + 0.5;
            ctx.stroke();
          }
        }

        // Add advanced water ripple effect
        function drawWaterRipples() {
          const imageData = ctx.createImageData(canvas.width, canvas.height);
          const data = imageData.data;

          for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
              const dx = x - canvas.width / 2;
              const dy = y - canvas.height / 2;
              const distance = Math.sqrt(dx * dx + dy * dy);

              // Create ripple pattern
              const ripple =
                Math.sin(distance * 0.1 - state.time * 5) * 0.5 + 0.5;

              // Apply color based on ripple value
              const index = (y * canvas.width + x) * 4;
              data[index] = ripple * 0; // R
              data[index + 1] = ripple * 100 + 100; // G
              data[index + 2] = ripple * 200 + 55; // B
              data[index + 3] = 255; // A
            }
          }

          ctx.putImageData(imageData, 0, 0);

          // Add light refraction highlights
          for (let i = 0; i < 50; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = Math.random() * 3 + 1;

            ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Add fractal effect
        function drawFractal() {
          const maxIterations = 100;
          const imageData = ctx.createImageData(canvas.width, canvas.height);
          const data = imageData.data;

          // Animate zoom and position
          const zoom = 4 * Math.pow(0.99, state.time * 10);
          const offsetX = -0.5 + Math.sin(state.time * 0.1) * 0.1;
          const offsetY = Math.cos(state.time * 0.13) * 0.05;

          for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
              const cRe =
                ((x - canvas.width / 2) * zoom) / canvas.width + offsetX;
              const cIm =
                ((y - canvas.height / 2) * zoom) / canvas.height + offsetY;

              let zRe = 0,
                zIm = 0;
              let iteration = 0;

              // Z = ZÂ² + C
              while (zRe * zRe + zIm * zIm < 4 && iteration < maxIterations) {
                const nextZRe = zRe * zRe - zIm * zIm + cRe;
                const nextZIm = 2 * zRe * zIm + cIm;

                zRe = nextZRe;
                zIm = nextZIm;

                iteration++;
              }

              // Color based on iteration count
              const index = (y * canvas.width + x) * 4;
              if (iteration === maxIterations) {
                // Inside the set - black
                data[index] = 0;
                data[index + 1] = 0;
                data[index + 2] = 0;
                data[index + 3] = 255;
              } else {
                // Outside - colorful gradient based on escape speed
                const normalizedIter = iteration / maxIterations;
                const hue = (normalizedIter * 360 + state.time * 30) % 360;

                // HSL to RGB conversion (simplified)
                const c = 1 - Math.abs(2 * normalizedIter - 1);
                const x = c * (1 - Math.abs(((hue / 60) % 2) - 1));
                const m = normalizedIter - c / 2;

                let r, g, b;
                if (hue < 60) {
                  r = c;
                  g = x;
                  b = 0;
                } else if (hue < 120) {
                  r = x;
                  g = c;
                  b = 0;
                } else if (hue < 180) {
                  r = 0;
                  g = c;
                  b = x;
                } else if (hue < 240) {
                  r = 0;
                  g = x;
                  b = c;
                } else if (hue < 300) {
                  r = x;
                  g = 0;
                  b = c;
                } else {
                  r = c;
                  g = 0;
                  b = x;
                }

                data[index] = Math.floor((r + m) * 255);
                data[index + 1] = Math.floor((g + m) * 255);
                data[index + 2] = Math.floor((b + m) * 255);
                data[index + 3] = 255;
              }
            }
          }

          ctx.putImageData(imageData, 0, 0);
        }

        // Add 3D terrain effect with ray marching
        function drawTerrain() {
          const imageData = ctx.createImageData(canvas.width, canvas.height);
          const data = imageData.data;

          // Camera movement
          const cameraX = Math.sin(state.time * 0.3) * 10;
          const cameraZ = state.time * 3;

          for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
              // Ray direction
              const rayDirX =
                ((x - canvas.width / 2) / (canvas.width / 2)) * 0.8;
              const rayDirY = 0.5 - y / canvas.height; // Looking downward
              const rayDirZ = 1.0;

              // Ray marching
              let dist = 0;
              let hitTerrain = false;

              for (let step = 0; step < 100; step++) {
                const posX = cameraX + rayDirX * dist;
                const posY = 1.5 + rayDirY * dist;
                const posZ = cameraZ + rayDirZ * dist;

                // Sample terrain height at this position
                const terrainHeight = terrainNoise(posX * 0.1, posZ * 0.1) * 2;

                // Check if we hit the terrain
                if (posY < terrainHeight) {
                  hitTerrain = true;
                  break;
                }

                dist += 0.2;

                // Max distance
                if (dist > 50) break;
              }

              // Color based on distance and hit
              const index = (y * canvas.width + x) * 4;
              if (hitTerrain) {
                // Terrain color based on distance (fog effect)
                const fogFactor = Math.min(1, dist / 50);

                // Mix between terrain color and fog color
                const r = 50 * (1 - fogFactor) + 0 * fogFactor;
                const g = 150 * (1 - fogFactor) + 0 * fogFactor;
                const b = 50 * (1 - fogFactor) + 100 * fogFactor;

                data[index] = r;
                data[index + 1] = g;
                data[index + 2] = b;
                data[index + 3] = 255;
              } else {
                // Sky color gradient
                const skyFactor = 1 - y / canvas.height;
                data[index] = 0;
                data[index + 1] = 0;
                data[index + 2] = 100 * skyFactor;
                data[index + 3] = 255;
              }
            }
          }

          ctx.putImageData(imageData, 0, 0);

          // Add stars to the sky
          for (let i = 0; i < 100; i++) {
            const starX = Math.random() * canvas.width;
            const starY = Math.random() * canvas.height * 0.5;

            if (Math.random() > 0.9) {
              const starSize = Math.random() * 2 + 1;
              ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
              ctx.beginPath();
              ctx.arc(starX, starY, starSize, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }

        function terrainNoise(x, z) {
          return (
            Math.sin(x) * Math.cos(z) * 0.5 +
            Math.sin(x * 0.1) * Math.cos(z * 0.15) * 2 +
            Math.sin(x * 2) * Math.cos(z * 2) * 0.2
          );
        }

        // Add enhanced Tesla tribute effect when Tesla appears in greetz
        function drawTeslaTribute() {
          // Draw lightning bolts
          ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
          ctx.lineWidth = 2;

          for (let i = 0; i < 5; i++) {
            // Start lightning from top
            let x = canvas.width / 2 + (Math.random() * 100 - 50);
            let y = 50;

            ctx.beginPath();
            ctx.moveTo(x, y);

            // Create zig-zag pattern
            while (y < canvas.height - 50) {
              x += Math.random() * 30 - 15;
              y += Math.random() * 20 + 10;
              ctx.lineTo(x, y);
            }

            ctx.stroke();

            // Add glow effect
            ctx.shadowColor = "#00ffff";
            ctx.shadowBlur = 10;
            ctx.stroke();
            ctx.shadowBlur = 0;
          }

          // Draw Tesla coil
          drawTeslaCoil(canvas.width / 2, canvas.height - 100, 80);

          // Add "FUCK THOMAS EDISON" with extreme glitch effect
          const edisonText = "FUCK THOMAS EDISON";
          ctx.font = '24px "Press Start 2P", monospace';

          for (let i = 0; i < edisonText.length; i++) {
            // Extreme glitch positioning
            const x =
              canvas.width / 2 -
              edisonText.length * 10 +
              i * 20 +
              (Math.random() * 10 - 5);
            const y = canvas.height / 2 + (Math.random() * 10 - 5);

            // Random color shifts between red and white
            const glitchIntensity = Math.random();
            if (glitchIntensity > 0.7) {
              ctx.fillStyle = "#ff0000";
            } else if (glitchIntensity > 0.4) {
              ctx.fillStyle = "#ffffff";
            } else {
              ctx.fillStyle = "#ffff00";
            }

            ctx.fillText(edisonText[i], x, y);

            // Occasional character duplication for extra glitch effect
            if (Math.random() > 0.8) {
              ctx.fillStyle = "rgba(255, 0, 0, 0.7)";
              ctx.fillText(
                edisonText[i],
                x + (Math.random() * 8 - 4),
                y + (Math.random() * 8 - 4)
              );
            }
          }
        }

        function drawTeslaCoil(x, y, size) {
          // Base of coil
          ctx.fillStyle = "#333";
          ctx.fillRect(x - size / 3, y - size / 10, (size * 2) / 3, size / 5);

          // Primary coil
          ctx.fillStyle = "#222";
          ctx.beginPath();
          ctx.ellipse(x, y - size / 6, size / 2, size / 10, 0, 0, Math.PI * 2);
          ctx.fill();

          // Secondary coil (vertical cylinder)
          ctx.fillStyle = "#444";
          ctx.fillRect(x - size / 6, y - size, size / 3, size);

          // Toroid at top
          ctx.fillStyle = "#555";
          ctx.beginPath();
          ctx.ellipse(x, y - size, size / 2, size / 8, 0, 0, Math.PI * 2);
          ctx.fill();

          // Sparks from toroid
          const sparkCount = 8;
          for (let i = 0; i < sparkCount; i++) {
            const angle = (i / sparkCount) * Math.PI * 2 + state.time;
            let sparkX = x;
            let sparkY = y - size;

            ctx.beginPath();
            ctx.moveTo(sparkX, sparkY);

            // Create branching lightning
            for (let j = 0; j < 10; j++) {
              const dist = (j * size) / 15;
              sparkX = x + Math.cos(angle) * dist + (Math.random() * 10 - 5);
              sparkY =
                y - size + Math.sin(angle) * dist + (Math.random() * 10 - 5);
              ctx.lineTo(sparkX, sparkY);
            }

            ctx.strokeStyle = `rgba(100, 200, 255, ${0.7 + Math.random() * 0.3})`;
            ctx.lineWidth = 1 + Math.random();
            ctx.stroke();
          }
        }

        // Add audio visualization effect
        function drawAudioVisualization() {
          // Create fake audio data
          const bands = 32;
          const fakeAudioData = Array(bands)
            .fill()
            .map(
              () =>
                Math.pow(Math.random(), 2) * 0.5 +
                Math.sin(state.time * 10) * 0.2 +
                Math.sin(state.time * 5) * 0.3
            );

          // Draw bars
          const barWidth = canvas.width / bands;

          for (let i = 0; i < bands; i++) {
            const height = fakeAudioData[i] * canvas.height * 0.5;
            const hue = ((i / bands) * 360 + state.time * 50) % 360;

            // Mirror effect
            ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.8)`;

            // Top bar
            ctx.fillRect(
              i * barWidth,
              canvas.height / 2 - height / 2,
              barWidth - 1,
              height
            );

            // Reflection (with gradient)
            const gradient = ctx.createLinearGradient(
              0,
              canvas.height / 2,
              0,
              canvas.height / 2 + height / 2
            );
            gradient.addColorStop(0, `hsla(${hue}, 100%, 50%, 0.8)`);
            gradient.addColorStop(1, `hsla(${hue}, 100%, 50%, 0)`);

            ctx.fillStyle = gradient;
            ctx.fillRect(
              i * barWidth,
              canvas.height / 2,
              barWidth - 1,
              height / 2
            );
          }

          // Add circular frequency visualization
          ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
          ctx.lineWidth = 2;
          ctx.beginPath();

          for (let i = 0; i <= 360; i++) {
            const angle = (i * Math.PI) / 180;
            const radiusBase = canvas.width / 5;
            const radiusAdd = Math.sin(i * 8 + state.time * 10) * 20;
            const x =
              canvas.width / 2 + Math.cos(angle) * (radiusBase + radiusAdd);
            const y =
              canvas.height / 2 + Math.sin(angle) * (radiusBase + radiusAdd);

            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }

          ctx.closePath();
          ctx.stroke();
        }

        // Initialize animation
        animate();

    function resizeCanvas() {
  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;
}

window.addEventListener("resize", () => {
  resizeCanvas();
});

// Call once initially
resizeCanvas();
      }); // <-- Close DOMContentLoaded event handler
    </script></body>
</html>
